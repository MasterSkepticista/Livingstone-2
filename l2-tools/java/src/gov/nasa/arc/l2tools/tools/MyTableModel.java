//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
package gov.nasa.arc.l2tools.tools;

import javax.swing.table.AbstractTableModel;
import javax.swing.DefaultListModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import java.util.ArrayList;
import java.util.Vector;

import livdll.CandidateAssignment;
import gov.nasa.arc.l2tools.gui.table.multispancell.*;

// Candidate Manager Table Model

public class MyTableModel extends AttributiveCellTableModel implements ListDataListener {

  // CandidateManager, using GroupableTableHeader
  // produced |   Rank   |
  //               |     |    |
  // but it does not work under JDK1.3 - source code not available
//   private static final String[] columnNames = {"Num",
// 					"",
// 					"",
// 					"Time",
// 					"Failures",};
  private static final String[] columnNames = {"Num",
					"  Ra",
					"nk  ",
					"Time",
					"Failures",};
  public static final String THE_EMPTY_CANDIDATE = "<the empty candidate>";

  private int[] canMap;
  private Vector selMap;
  private String listType; // candidates or candidateClasses

  public MyTableModel( String listType) {
    super(columnNames, 0);
    canMap = new int[0];
    if (listType.equals( "candidates") || listType.equals( "candidateClasses")) {
      this.listType = listType;
    } else {
      System.err.println( "MyTableModel does not handle listType " + listType);
      System.exit( 0);
    }
  }

  // ListDataListener interface

  // Sent when the contents of the list has changed in a way that's too complex to characterize with the previous methods.
  public void contentsChanged(ListDataEvent e) {
    EngineModelBean bean = (EngineModelBean)e.getSource();
    clear();
    if (listType.equals( "candidates")) {
      setCandidates( bean.getCandidates());
    } else if (listType.equals( "candidateClasses")) {
      setCandidates( bean.getCandidateClasses());
    }
  }

  // Sent after the indices in the index0,index1 interval have been inserted in the data model.
  public void intervalAdded(ListDataEvent e) {
    contentsChanged(e);
  }

  // Sent after the indices in the index0,index1 interval have been removed from the data model.
  public void intervalRemoved(ListDataEvent e) {
    contentsChanged(e);
  }

  public boolean isTheEmptyCandidate( CandidateAssignment[] assigns) {
    String[] pair0 = LivingstoneEngine2.breakAtSubstring
      ( assigns[0].getAttribute(), "#");
    return (assigns.length == 1) && ("".equals( pair0[1]));
  }

  public void setCandidates(Candidate[] candidates) {
      if(candidates == null || candidates.length == 0) {
	clear();
	return;
      }
      int d = 0;
      for(int i = 0; i < candidates.length; i++) {
	  Vector newrow = new Vector(columnNames.length);
	  Candidate c = candidates[i];
	  newrow.add(new Integer(i));
	  newrow.add(new Integer((int)c.getWeight()));
	  CandidateAssignment[] assigns = c.getCandidateAssignments();
          // System.err.println("MyTableModel.setCandidates: name " + assigns[0].getAttribute() + " len " + assigns.length + " val " + assigns[0].getValue());
          // getAttribute is <time># for zero cost candidate
          String[] pair0 = LivingstoneEngine2.breakAtSubstring(assigns[0].getAttribute(), "#");
// 	  if ((assigns.length == 0) ||
//               ((assigns.length == 1) && ("".equals( pair0[1])))) {
          if (isTheEmptyCandidate( assigns)) {
              // new interface with livdll: mapOverCandidateAssignmentsJNI for
              // zero-cost candidate
              newrow.add("0");
              if (listType.equals( "candidateClasses")) { pair0[0] = ""; }
              newrow.add(pair0[0]);
              // newrow.add(THE_EMPTY_CANDIDATE);
              assigns[0].setText( THE_EMPTY_CANDIDATE);
              newrow.add( assigns[0]);
	  } else {
              // assignments are now reversed -- do this so that order of
              // listing is the same as generated by L2 at cmd line
              // get last one is list, not the first
              int jj = assigns.length - 1;
	      newrow.add(new Integer((int)assigns[jj].getWeight()));
	      String[] pair = LivingstoneEngine2.breakAtSubstring(assigns[jj].getAttribute(), "#");
	      if(pair[1] == "") {
		pair[1] = pair[0];
		pair[0] = "n/a";
	      }
              if (listType.equals( "candidateClasses")) { pair[0] = ""; }
	      newrow.add(pair[0]);
	      // newrow.add(cleanUpAttribute(pair[1])+"="+assigns[jj].getValue());
              assigns[jj].setText( cleanUpAttribute( pair[1]) + "=" +
                                   assigns[jj].getValue());
	      newrow.add( assigns[jj]);
	  }
	  d++;
	  addRow(newrow);
	  if(assigns.length > 1) {
	    // for(int ii = 1; ii < assigns.length; ii++) {
            // assignments are now reversed -- do this so that order of
            // listing is the same as generated by L2 at cmd line
	    for(int ii = assigns.length - 2; ii >= 0; ii--) {
	      newrow = new Vector(columnNames.length);
	      newrow.add("");
	      newrow.add("");
	      newrow.add(new Integer((int)assigns[ii].getWeight()));
	      String[] pair = LivingstoneEngine2.breakAtSubstring(assigns[ii].getAttribute(), "#");
	      if(pair[1] == "") {
		pair[1] = pair[0];
		pair[0] = "n/a";
	      }
              if (listType.equals( "candidateClasses")) { pair[0] = ""; }
	      newrow.add(pair[0]);
	      // newrow.add(cleanUpAttribute(pair[1])+"="+assigns[ii].getValue());
              assigns[ii].setText( cleanUpAttribute( pair[1]) + "=" +
                                   assigns[ii].getValue());
	      newrow.add( assigns[ii]);
	      d++;
	      addRow(newrow);
	    }
	  }
      }

      canMap = new int[d];
      selMap = new Vector();
      d = 0;
      for(int i = 0; i < candidates.length; i++) {
	Candidate cans = candidates[i];
	CandidateAssignment[] assigns = cans.getCandidateAssignments();
	int numOfLines = assigns.length;
	if(numOfLines == 0) numOfLines = 1;
	int[] c = new int[numOfLines];
	c[0] = i+d;
	canMap[i+d] = i;
	int[] sel = new int[numOfLines];
	sel[0] = i+d;
	if(numOfLines > 1) {
	  for(int ii = 1; ii < numOfLines; ii++) {  
	    c[ii] = i+ii+d;
	    canMap[i+ii+d] = i;
	    sel[ii] = i+ii+d;
	  }
	  d = d + assigns.length - 1;
	  CellSpan cs = (CellSpan)getCellAttribute();
	cs.combine(c,new int[]{0});
	cs.combine(c,new int[]{1});
	}
	selMap.add(sel);
      }
  }

  public int getCandidateFor(int i) {
    if(i > -1 && i < canMap.length) return canMap[i];
    else return -1;
  }

  public int[] getSelectionFor(int i) {
    if(i > -1 && i < selMap.size()) return (int[])selMap.elementAt(i);
    else return new int[0];
  }

  public void clear() {
    dataVector = new Vector();
    setNumRows(0);
    getCellAttribute().setSize(new java.awt.Dimension(5,1));
  }

  // This was added because of a user request to remove redundant data
  private String cleanUpAttribute(String att) {
    if(att.startsWith("test.")) 
      att = att.substring(5);
    if(att.endsWith(".modeTransition"))
      att = att.substring(0,att.length()-15);
    return att;
  }
}
