//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

package gov.nasa.arc.l2tools.tools;

import livdll.*;
import java.io.File;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.Vector;
import javax.swing.DefaultListModel;
import gov.nasa.arc.l2tools.tools.LivingstoneCBFSEngine;
import gov.nasa.arc.l2tools.tools.LivingstoneCoverEngine;

public class LivingstoneEngineAdapter implements ScenarioInterface {

  private LivingstoneEngine2 engine = null;
  // determined from newEngine args plus loadModel (in L2) reading the
  // optional <model-name>.params file
  private String engine_search_method = new String( "");
  // ptr to C++ Livingstone_debug class, returned by
  // setCBFSEngineParams or setCoverEngineParams
  private int L2_ptr = -1;
  /* Supports generation of events for the GUI */
  private Vector engineListeners = new Vector();
  // cache of history
  private AttributeAssignment[][] attributeAssignments = null;
  private Candidate attributeAssignmentsCandidate = null;

  // Second implementation for testing
  private AttributeAssignment[][] attributeAssignments2 = null;
  private Candidate attributeAssignmentsCandidate2 = null;

  /* This just clears out the caches. */
  public void cleanup() {
    attributeAssignments = null;
    attributeAssignmentsCandidate = null;
    attributeAssignments2 = null;
    attributeAssignmentsCandidate2 = null;
  }

  public LivingstoneEngine2 getEngine () {
    return engine;
  }

  public void addEngineListener(EngineListener el) {
    if(!engineListeners.contains(el)) engineListeners.addElement(el);
  }

  public void removeEngineListener(EngineListener el) {
    engineListeners.removeElement(el);
  }
  public void loadModel(Object source, String filename) throws L2NativeException {
    System.err.println("LivingstoneEngineAdapter.loadModel: enter");
    if (L2_ptr == -1) throw new L2NativeException("specify `newEngine ...' first");
    cleanup();
    String engine_search_method = LivingstoneEngine.loadModelJNI(filename, L2_ptr);
    // now actually allocate the L2 tracker and debugger
    // from the Livingstone_debug object, which was allocated by
    // setCBFSEngineParamsJNI or setCoverEngineParamsJNI 
    if (engine_search_method.equals("cbfs")) {
      engine = LivingstoneCBFSEngine.factory( L2_ptr);
    } else if (engine_search_method.equals("cover")) {
      engine = LivingstoneCoverEngine.factory( L2_ptr);
    } else {
      throw new L2NativeException("engine search method `" + engine_search_method +
                                   "' not handled");
    }
    engine.modelFilename = filename;
    Enumeration enum = engineListeners.elements();
    while(enum.hasMoreElements()) { 
      ((EngineListener)enum.nextElement()).echoNewEngine(source, engine_search_method);
    }
    SortedSet namesAfterLastLoad = engine.getAttributeNames();
    enum = engineListeners.elements();
    while(enum.hasMoreElements()) {
      ((EngineListener)enum.nextElement()).echoLoadModel(source, filename,
                                                         namesAfterLastLoad);
    }
    System.err.println("LivingstoneEngineAdapter.loadModel: exit");
  }


  public void assign(Object source, String monitor) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    cleanup();
    // var=val
    // var1=val1 var2=val2 ... varn=valn
    engine.assign( monitor);
    Enumeration enum = engineListeners.elements();
    while(enum.hasMoreElements())
      ((EngineListener)enum.nextElement()).echoMonitor(source, monitor);
  }

  public void unassign(Object source, String monitor) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    cleanup();
    // monitor is only var
    engine.unassign( monitor);
    // echo var=unknown
    String unknownMonitor = new String( monitor);
    unknownMonitor = unknownMonitor.concat( new String( "=unknown"));
    Enumeration enum = engineListeners.elements();
    while(enum.hasMoreElements())
      ((EngineListener)enum.nextElement()).echoMonitor(source, unknownMonitor);
  }

  public void updateCandidates() throws L2NativeException {
      findCandidates(this, "updateCandidates");
  }
  
  public void findCandidates(Object source, String command) throws L2NativeException {
    // System.out.println("==== LivingstoneEngineAdapter.findCandidates() called ===== command " + command);
    // command: fc findfresh or extend
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    Enumeration enum = engineListeners.elements();
    while(enum.hasMoreElements())
      ((EngineListener)enum.nextElement()).echoFindCandidates(source);
    //    System.out.println("send out echo"); 
    engine.findCandidates( command );
    Candidate[] candidates = engine.getCandidates();
    // System.out.println("LEA.findCandidates Candidates " + candidates.length);
    Candidate[] candidateClasses = engine.getCandidateClasses();
    // System.out.println("LEA.findCandidates CandidateClasses " + candidateClasses.length);
    Vector discrepancys = engine.getDiscrepancys();  //Added By RG
    String searchTerm = engine.getSearchTermination();
    enum = engineListeners.elements();
    while(enum.hasMoreElements())
      ((EngineListener)enum.nextElement()).replyFoundCandidates
        (source, candidates, candidateClasses, discrepancys, searchTerm);
  }

  public Attribute[] getAttributes(Object source, boolean clearCache) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    if(clearCache) engine.buildAttributes();
    return engine.getAttributes();
  }

  public SortedSet getAttributeNames(Object source) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getAttributeNames();
  }

  public AttributeAssignment[][] getAttributeAssignments(Object source, Candidate c) throws IndexOutOfBoundsException, L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    if(c == null || c != attributeAssignmentsCandidate) cleanup();
    if(attributeAssignments == null) {
      attributeAssignments =  engine.getAttributeAssignments(c);
      attributeAssignmentsCandidate = c;
    }
    return attributeAssignments;
  }

  // Second implementation
  public AttributeAssignment[][] getAttributeAssignments2(Object source, Candidate c, Collection names) throws IndexOutOfBoundsException, L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    if(c == null || c != attributeAssignmentsCandidate2) cleanup();
    if(attributeAssignments2 == null) {
      attributeAssignments2 =  engine.getAttributeAssignments2(c,names);
      attributeAssignmentsCandidate2 = c;
    }
    return attributeAssignments2;
  }

  public Candidate[] getCandidates() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getCandidates();
  }

  public Candidate[] getCandidateClasses() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getCandidateClasses();
  }

  public int getCandidateCount() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getCandidateCount();
  }
  
  //Added By RG
  public Vector getDiscrepancys() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");   
    return engine.getDiscrepancys(); 
  }
   
   
  public int[] getHistoryStartStop() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getHistoryStartStop();
  }

  public void execWarpCommands(String commands) throws L2NativeException {
    if (engine == null) throw new L2NativeException("No L2 engine running; try help");
    engine.execWarpCommands(commands);
  }

  public String getSearchTermination() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getSearchTermination();
  }

  public boolean parseCmd (String cmd, String args) throws L2NativeException {
    if (engine == null)
      return false;
    return engine.parseCmd(cmd, args);
  }

  public void listenerUsage() throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    engine.listenerUsage();
  }

  public void newEngine(Object source, String search_method,
                        int max_candidate_classes_returned,
                        int max_candidates_returned, int max_candidates_searched,
                        int max_cutoff_weight, int max_history_cutoff,
                        int max_trajectories_tracked, String progress_cmd_type,
                        String fc_cmd_type) throws IllegalArgumentException, L2NativeException {

    // better check our arguments
    if (! (search_method.equals("CBFS") || search_method.equals("COVER"))) {
      System.out.println("LivingstoneCommandLine constructor does not like first parameter");
      throw new IllegalArgumentException("search_method - (CBFS or COVER)");
    }
    if(!((max_candidate_classes_returned > -1 && max_candidate_classes_returned < 101) && 
         (max_candidates_returned > 0 && max_candidates_returned < 1001) && 
         (max_candidates_searched > 99 && max_candidates_searched < 100001) &&
         (max_cutoff_weight > 0 && max_cutoff_weight < 1001) &&
         (max_history_cutoff > -1 && max_history_cutoff < 101) &&
         (max_trajectories_tracked > 0 && max_trajectories_tracked < 101) &&
         (progress_cmd_type.equals("min") || progress_cmd_type.equals("full")) &&
         (fc_cmd_type.equals("extend") || fc_cmd_type.equals("prune-search") ||
          fc_cmd_type.equals("find-fresh")))) {
      System.out.println("LivingstoneCommandLine constructor does not like one of the parameters");
      if (search_method.equals("CBFS"))
        throw new IllegalArgumentException("\nmax_candidate_classes_returned - (0-100)\nmax_candidates_returned - (1-1000)\nmax_candidates_searched - (100-100000)\nmax_cutoff_weight - (1-1000)\nmax_history_cutoff - (0-100)\nmax_trajectories_tracked - (1-100)\nprogress_cmd_type - (min | full)\nfc_cmd_type - (extend | prune-search | find-fresh)");
      if (search_method.equals("COVER"))
        throw new IllegalArgumentException("\nmax_candidate_rank - (1-1000)\ndummy1 - 100\ndummy2 - 100\nmax_history_cutoff - (0-100)\nmax_trajectories_tracked - (1-100)\nprogress_cmd_type - (min | full)\nfc_cmd_type - (extend | prune-search | find-fresh)");
    }
    if (engine != null) LivingstoneEngine2.deallocate(engine);
    engine = null;
    L2_ptr = -1;
    cleanup();

    if (search_method.equals("CBFS")) {
      L2_ptr = LivingstoneCBFSEngine.setCBFSEngineParams( max_candidate_classes_returned, max_candidates_returned, max_candidates_searched, max_cutoff_weight, max_history_cutoff, max_trajectories_tracked, progress_cmd_type, fc_cmd_type);

    } else if(search_method.equals("COVER")) {
      int max_candidate_rank = max_candidates_returned;
      L2_ptr = LivingstoneCoverEngine.setCoverEngineParams( max_candidate_rank, max_history_cutoff, max_trajectories_tracked, progress_cmd_type, fc_cmd_type);
    }
  }

  public void destroyEngine(Object source) throws L2NativeException {
    cleanup();
    if(engine != null) LivingstoneEngine2.deallocate(engine);LivingstoneEngine2
    engine = null;
    Enumeration enum = engineListeners.elements();
    while(enum.hasMoreElements())
      ((EngineListener)enum.nextElement()).echoDestroyEngine(source);
  }

  public void minProgress(Object source, String command) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    cleanup();
    engine.minProgress(command);
    Enumeration enum = engineListeners.elements();
    //    while(enum.hasMoreElements())
    //      ((EngineListener)enum.nextElement()).echoCommand(source, command);
    while(enum.hasMoreElements()) {
      EngineListener l = (EngineListener)enum.nextElement();
      l.echoCommand(source, command);
    }
  }

  public void fullProgress(Object source, String command) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    cleanup();
    engine.fullProgress(command);
    Enumeration enum = engineListeners.elements();
    //    while(enum.hasMoreElements())
    //      ((EngineListener)enum.nextElement()).echoCommand(source, command);
    while(enum.hasMoreElements()) {
      EngineListener l = (EngineListener)enum.nextElement();
      l.echoCommand(source, command);
    }
  }

  public boolean propagate(Object source) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    cleanup();
    boolean consistent = engine.propagate();
    Enumeration enum = engineListeners.elements();
    while(enum.hasMoreElements())
      ((EngineListener)enum.nextElement()).echoPropagate(source, consistent);
    return consistent;
  }

  public LivingstoneEngine2.PropValueResponse getPropValue(String propName) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getPropValue(propName);
  }

  public LivingstoneEngine2.JustificationStruct justificationStruct(String propName) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.justificationStruct(propName);
  }

  public String variableValueAtTime(String vname, int time) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.variableValueAtTime(vname,time);
  }

  /* returns an array of two strings.  The first is the string before
     the first occurance of pattern.  The second is the string after
     the first occurance.  If pattern does not occur in line, then return
     [<line>,""]. */
  public static String[] breakAtSubstring(String line, String pattern) {
    String[] result = new String[2];
    
    int i = line.indexOf(pattern);
    if (i<0) {
      result[0] = line;
      result[1] = "";
    } else {
      result[0] = line.substring(0,i);
      result[1] = line.substring(i+pattern.length());
    }
    return result;
  }

  public boolean restoreCheckpoint(Object source, String name) throws L2NativeException {
    return engine.restoreCheckpoint( name);
  }



  // JNI testing only
  public SortedSet getCommandAttributeNames(Object source) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getCommandAttributeNames();
  }

  // JNI testing only
  public SortedSet getObservableAttributeNames(Object source) throws L2NativeException {
    if(engine == null) throw new L2NativeException("No L2 engine running; try help");
    return engine.getObservableAttributeNames();
  }
 
  // JNI testing only
  public boolean setAttributeMode(Object source, String args) throws L2NativeException {
    String[] pair = LivingstoneEngine2.breakAtSubstring( args," ");
    return engine.setAttributeMode( pair[0], pair[1]);
  }

  // JNI testing only
  public void createCheckpoint(Object source, String name) throws L2NativeException {
    engine.createCheckpoint( name);
  }

  // JNI testing only
  public void deleteCheckpoint(Object source, String name) throws L2NativeException {
    engine.deleteCheckpoint( name);
  }

  // JNI testing only
  public void addAssumption(Object source, String name) throws L2NativeException {
    engine.addAssumption( name);
  }

}
