//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

package gov.nasa.arc.l2tools.tools;

import livdll.L2NativeException;
import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.WindowEvent;
import javax.swing.JFrame;
//import gov.nasa.arc.l2tools.gui.BrowserFrame;
import gov.nasa.arc.l2tools.tools.StanleyAdapter;
import gov.nasa.arc.l2tools.tools.LivingstoneEngineAdapter;
import gov.nasa.arc.l2tools.tools.historyTable.HistoryTable;
// for getCmds getObservables
import java.util.SortedSet;
import java.util.Iterator;

public class CommandLine implements Tool {

  private EngineManager engineManager;
  private DataModel model;
  // allow for copies of History Table
  private List historyTableArray; // elements HistoryTable
  private List historyTableLocationArray;  // elements Point
  private List historyTableSizeArray; // elements Dimension

  public CommandLine(EngineManager engineManager, DataModel model) {
    this.engineManager = engineManager;
    setModel(model);
    readBuffer();
    
    historyTableArray = new ArrayList();
    historyTableLocationArray = new ArrayList();
    historyTableSizeArray = new ArrayList();
  } // end constructor

  public java.awt.Container getContainer() { return null; }

  public void setModel(DataModel model) { this.model = model; }

  public DataModel getModel() { return model; }

  // allow forWill/Server to save its instance of HT for CommandLine usage
  // and for History Table Copy command
  public void addHistoryTable( HistoryTable historyTable) {
    historyTableArray.add( historyTable);
    historyTableLocationArray.add( new Point());
    historyTableSizeArray.add( new Dimension());
  }

  private void readBuffer() {
    Thread thread = new Thread(new Runnable() {
	public void run() {
	  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	  try {
	    System.out.println("Type 'exit' to quit the server.");
	    while (true) {
	      // System.out.print("StanleyAdapter ======> ");
	      String line = in.readLine();
	      // System.out.print("StanleyAdapter line " + line);
	      if (line != null) {
		  //		if ("exit".equalsIgnoreCase(line)) System.out.println("just kidding, you can't really exit");
		line = line.trim();
		// Is this a comment?
		if (line.length()>1 && line.substring(0,2).equals("//")) 
		  return;
		// separate the line's name from the arguments
		String[] pair = LivingstoneEngine2.breakAtSubstring(line," ");
		try {
		  dispatchCommand(pair[0].trim(),pair[1].trim());
		} catch (Exception e) {
		  e.printStackTrace();
		}
	      }
	    }
	  } catch (java.io.IOException e) { e.printStackTrace(); }
	}
      });
    //    thread.start();
  }

  public synchronized void dispatchCommand(String  cname, String args) throws L2NativeException, IndexOutOfBoundsException, IOException {
    ScenarioInterface pipeline = model.getPipeline();
    // System.err.println("CommandLine.dispatchCommand canme " + cname + " args " + args);
    if (pipeline == null) throw new L2NativeException("pipeline is null");
    else {
      if ("".equalsIgnoreCase(cname)) {
        // carriage return - do nothing - allow prompt to be output
      } else if ("newEngine".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
        // start a new engine
	StringTokenizer s = new StringTokenizer(args," ");
	if (s.countTokens() == 9) {
	  String search_method = s.nextToken();
	    int max_candidate_classes_returned = Integer.parseInt(s.nextToken());
	    int max_candidates_returned = Integer.parseInt(s.nextToken());
	    int max_candidates_searched = Integer.parseInt(s.nextToken());
	    int max_cutoff_weight = Integer.parseInt(s.nextToken());
	    int max_history_steps = Integer.parseInt(s.nextToken());
            int max_trajectories_tracked = Integer.parseInt(s.nextToken());
            String progress_cmd_type = s.nextToken();
            String fc_cmd_type = s.nextToken();
            try {
              pipeline.newEngine(this, search_method, max_candidate_classes_returned,
                                 max_candidates_returned, max_candidates_searched,
                                 max_cutoff_weight, max_history_steps,
                                 max_trajectories_tracked, progress_cmd_type, fc_cmd_type);
            }
            catch (IllegalArgumentException e) {
              System.out.println(e);
            }
        } else {
          System.out.println("Invalid arguments to newEngine:");
          showNewEngineArgs();
        }
      } else if("destroyEngine".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	pipeline.destroyEngine(this);
      } else if("scenario".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	System.out.println("scenario not implemented");
      } else if("loadModel".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	StringTokenizer s2 = new StringTokenizer(args," ");
	if (s2.countTokens() == 1) {
          // if historyTables exist, kill them and start new ones
          // to prevent messy errors
          // boolean reloadHistoryTablesP = deleteHistoryTables();
	  String modelFile = s2.nextToken();
          pipeline.loadModel(this, modelFile);
          // if (reloadHistoryTablesP) {
          //   createHistoryTablesAtLocation();
          // }
        } else {
          System.err.println("Invalid arguments to loadModel:");
          System.err.println("  loadModel modelFile - (model pathname)\n");
        }
      } else if("min-progress".equalsIgnoreCase(cname)) {
        // min-progress cmd=assignment
        // min-progress ""    (idle progress)
        if (model.getEnableGUIUpdate())
          System.out.println("L2Tools.command(" + cname + " " + args + ")");
        pipeline.minProgress(this, args);
      } else if("full-progress".equalsIgnoreCase(cname)) {
        // full-progress cmd=assignment
        // full-progress ""    (idle progress)
        if (model.getEnableGUIUpdate())
          System.out.println("L2Tools.command(" + cname + " " + args + ")");
        pipeline.fullProgress(this, args);
      } else if("assign".equalsIgnoreCase(cname)) {
        // assign var=val
        // assign var1=val1 var2=val2 ... varn=valn
        if (model.getEnableGUIUpdate())
          System.out.println("L2Tools.command(" + cname + " " + args + ")");
	pipeline.assign(this, args);
      } else if("unassign".equalsIgnoreCase(cname)) {
        // unassign var=val
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	pipeline.unassign(this, args);
      } else if ("find-candidates".equalsIgnoreCase(cname) || "fc".equalsIgnoreCase(cname) ||
                  "prune-search".equalsIgnoreCase(cname) || 
                 "find-fresh".equalsIgnoreCase(cname) || "extend".equalsIgnoreCase(cname)) {
        if ("find-candidates".equalsIgnoreCase(cname))
          cname = "fc";
        if (! cname.equals( "fc"))
          System.out.println("L2Tools.command(" + cname + " " + args + ")");
        // pipeline.findCandidates handles println for fc
	pipeline.findCandidates(this, cname); 
      } else if("restore".equalsIgnoreCase(cname)) {
        // do not print "L2Tools.command(" since this is passed from StanleyAdapter.
        // disable all Stanley & History Table updates during time change --
        // let Candidate Mgr selection do it
        model.setEnableCandMgrOnlyUpdateOn();
        model.updateTimes();
        model.setEnableCandMgrOnlyUpdateOff();
        // if historyTables exist, kill them and start new ones
        // to prevent messy errors
        // if (deleteHistoryTables()) {
        //   createHistoryTablesAtLocation();
        // }
        // print out restored candidates
        pipeline.parseCmd("candidates", "");
        //  update all tools, e.g. Candidate Mgr
        pipeline.updateCandidates();
        
      } else if("truncate".equalsIgnoreCase(cname)) {
        // update Stanley, Candidate Mgr and History Table after truncate
        // do not print "L2Tools.command(" since this is passed from StanleyAdapter 
        model.updateTimes();
        // if historyTables exist, kill them and start new ones
        // to prevent messy errors
        // if (deleteHistoryTables()) {
        //   createHistoryTablesAtLocation();
        // }
        // candidates have not changed -- do not print or update them

        // testing only
      } else if("getCmds".equalsIgnoreCase(cname)) {
	SortedSet names = pipeline.getCommandAttributeNames(this);
        for (Iterator i=names.iterator();i.hasNext();) {
          String n = (String) i.next();
          System.err.println(n);
        }
          
        // testing only
      } else if("getObservables".equalsIgnoreCase(cname)) {
	SortedSet names = pipeline.getObservableAttributeNames(this); 
        for (Iterator i=names.iterator();i.hasNext();) {
          String n = (String) i.next();
          System.err.println(n);
        }

        // testing only: setMode test.--.mode nominal
      } else if("setMode".equalsIgnoreCase(cname)) {
	StringTokenizer s3 = new StringTokenizer(args, " ");
	if (s3.countTokens() != 2) {
          System.err.println("setMode args not valid");
          System.err.println("setMode <mode-variable-name> <mode-value>");
        } else {
          boolean consistentP = pipeline.setAttributeMode(this, args); 
          System.err.println("consistent: " + consistentP);
        }

        // testing only: createCheckpoint
      } else if("createCheckpoint".equalsIgnoreCase(cname)) {
	StringTokenizer s3 = new StringTokenizer(args, " ");
	if (s3.countTokens() != 1) {
          System.err.println("createCheckpoint args not valid");
          System.err.println("createCheckpoint <checkpoint-name>");
        } else {
          pipeline.createCheckpoint(this, args); 
        }

        // testing only: restoreCheckpoint
      } else if("restoreCheckpoint".equalsIgnoreCase(cname)) {
	StringTokenizer s4 = new StringTokenizer(args, " ");
	if (s4.countTokens() != 1) {
          System.err.println("restoreCheckpoint args not valid");
          System.err.println("restoreCheckpoint <checkpoint-name>");
        } else {
          pipeline.restoreCheckpoint(this, args); 
        }

        // testing only: deleteCheckpoint
      } else if("deleteCheckpoint".equalsIgnoreCase(cname)) {
	StringTokenizer s5 = new StringTokenizer(args, " ");
	if (s5.countTokens() != 1) {
          System.err.println("deleteCheckpoint args not valid");
          System.err.println("deleteCheckpoint <checkpoint-name>");
        } else {
          pipeline.deleteCheckpoint(this, args); 
        }

        // testing only: addAssumption
      } else if("addAssumption".equalsIgnoreCase(cname)) {
          pipeline.addAssumption(this, args); 

      } else if("historyTable".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
        System.out.println("bring up a history table");
        HistoryTable historyTable =
          (HistoryTable) engineManager.newHistoryTableTool(0);
        addHistoryTable( historyTable);
        historyTable.setVisible( true);
      } else if("attributeTable".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	System.out.println("bring up an attribute table");
	((JFrame)engineManager.newAttributeTableTool(0)).setVisible(true);
      } else if("modelBrowser".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
        // is a model loaded
        String modelFileName = model.getModel();
        // System.err.println("CommandLine.dispatchCommand: modelFilename " + modelFileName);
        if ("none".equalsIgnoreCase(modelFileName)) {
          System.out.println("No loaded L2 model");
        } else {
          System.out.println("bring up a model browser");
          String modelDir = new String( "  ");
          String modelRoot = new String( "  ");
          int stringIndex = 0;
          int stringLength = 0;
          // jmpl files are in same dir as xmpl file, unless model is in
          // stanley-sample-user-files
          // lop off file name and its directory, so that support jmpl files
          // are viewable
          stringIndex = modelFileName.lastIndexOf("/");
          stringLength = modelFileName.length();
          modelFileName = modelFileName.substring( 0, stringIndex);
          stringIndex = modelFileName.lastIndexOf("/");
          stringLength = modelFileName.length();
          modelRoot = modelFileName.substring( stringIndex + 1, stringLength);
          if (".stanley".equalsIgnoreCase(modelRoot)) {
            // if model is in stanley-sample-user-files, get jmpl files
            // location from env var, since xmpl file is in $HOME/.stanley/
            String l2toolsRoot = new String("null");
            try {
              // run a command
              String outlist[] = StanleyAdapter.runCommand("printenv L2TOOLS_ROOT");
              // display its output
              // for (int i = 0; i < outlist.length; i++)
              //   System.out.println("i " + i + " " + outlist[i]);
              l2toolsRoot = outlist[0];
            }
            catch (IOException e) {
              System.err.println(e);
            }
            // System.out.println("l2toolsRoot " + l2toolsRoot);
            if (! "null".equalsIgnoreCase(l2toolsRoot)) {
              modelDir = l2toolsRoot.concat("/stanley-sample-user-files/livingstone/models");
            } else {
              System.out.println("L2TOOLS_ROOT not found");
            }
          } else {
            modelDir = modelFileName.substring( 0, stringIndex);
          }
          // System.err.println("CommandLine.dispatchCommand: modelDir " + modelDir);
          if (! "  ".equalsIgnoreCase(modelDir)) {
            //new BrowserFrame( new File( modelDir));
            System.out.println("ModelBrowser not implemented");
          }
        }
      } else if("setSelectedCandidateIndex".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	int index = Integer.parseInt(args);
	Candidate[] cs = model.getCandidates();
	if(cs != null && index > -1 && index < cs.length)
	  model.setSelectedCandidate(cs[index]);
        else 
          System.out.println("out of bounds");
      } else if("setSelectedTimeStep".equalsIgnoreCase(cname)) {
        System.out.println("L2Tools.command(" + cname + " " + args + ")");
	int index = Integer.parseInt(args);
        if(index >= model.getStartTimeStep() && index <= model.getCurrentTimeStep())
          model.setSelectedTimeStep(index);
        else 
          System.out.println("out of bounds");

      } else if ("help".equalsIgnoreCase(cname)) {
        System.out.println("");
        System.out.println("L2 Tools commands:");
        System.out.println("-------------------");
        System.out.println("  newEngine CBFS <maxCandidateClasses>");
        System.out.println("      <maxCandidates> <maxSearch>");
        System.out.println("      <maxCutoffWeight> <maxHistory>");
        System.out.println("      <maxTrajectories>");
        System.out.println("      <progressCmdType> <fcCmdType>  - specify CBFS engine params");
        System.out.println("  newEngine COVER <maxRank> 100 100");
        System.out.println("      100 <maxHistory>");
        System.out.println("      <maxTrajectories> ");
        System.out.println("      <progressCmdType> <fcCmdType>  - specify COVER engine params");
        System.out.println("  loadModel <model-pathname>         - load model files (.xmpl, .ini, .hrn),");
        System.out.println("                                       allocate engine");
        System.out.println("  destroyEngine                      - deallocate current engine");
//         System.out.println("  assign <var1>=<val1> ...");
//         System.out.println("                 <varn>=<valn>   - assign 1 or more variables at current time");
//         System.out.println("  unassign <var>                 - unassign variable");
//         System.out.println("  min-progress <cmd-assignment>  - issue a minimal progress command");
//         System.out.println("  min-progress                   - idle minimal progress");
//         System.out.println("  full-progress <cmd-assignment> - issue a full progress command");
//         System.out.println("  full-progress                  - idle full progress");
//         System.out.println("  findCandidates    or fc        - find candidates");
        // System.out.println("  scenario <name>                - mark the start of a scenario");
        System.out.println("");
        System.out.println("  historyTable                   - start a History Table tool");
        System.out.println("");
        System.out.println("  refresh                        - send current L2 state to Stanley");
        System.out.println("                                   and History Table");
        // System.out.println("  attributeTable                 - start Attribute Table tool");
        System.out.println("  modelBrowser                   - browse jmpl code of loaded model");
        System.out.println("");
        // System.out.println("  stanleyViewer                  - start Stanley in Viewer mode");
        // System.out.println("  stanleyViewer modelState       - init current model state in Stanley Viewer");
        //           System.out.println("    stanleyViewer getWorkspaces  - get Stanley workspaces");
        //           System.out.println("    stanleyViewer loadWorkspace");
        //           System.out.println("            <workspace pathname> - load Stanley workspace");
        //           System.out.println("    stanleyViewer getModules     - get Stanley workspace modules/components");
        //           System.out.println("    stanleyViewer loadModule");
        //           System.out.println("                    <moduleName> - load workspace module/component");
        //           System.out.println("    stanleyViewer getInstances");
        //           System.out.println("                        terminal - get terminal instance names");
        //           System.out.println("                       attribute - get attribute instance names");
        //           System.out.println("                          module - get module instance names");
        //           System.out.println("                       component - get component instance names");
        //           System.out.println("            mode <componentName> - get mode instance names for component");
        //           System.out.println("    stanleyViewer metaDot");
        //           System.out.println("                         terminal <terminalName> - terminal instance info");
        //           System.out.println("                       attribute <attributeName> - attribute instance info");
        //           System.out.println("                 module <moduleName> nameArgsDoc - module instance info");
        //           System.out.println("              module moduleName displayAttribute - module displayAttribute info");
        //           System.out.println("                       module <moduleName> facts - module facts");
        //           System.out.println("           component <componentName> nameArgsDoc - component instance info");
        //           System.out.println("      component <componentName> displayAttribute - component displayAttribute info");
        //           System.out.println("       component <componentName> backgroundModel - component backgroundModel");
        //           System.out.println("     component <componentName> initialConditions - component initialConditions");
        //           System.out.println("       component <componentName> mode <modeName> - component mode info");
        //           System.out.println("     component <componentName> transitions <modeName> - component mode transitions info");

        System.out.println("");
        // print L2 commands
        try {
          pipeline.listenerUsage();
        }
        catch (L2NativeException e) {
          System.err.println(e);
        }
        System.out.println("-------------------");
        System.out.println("  exit");
        System.out.println("");

      } else {
        boolean known = true;
        // is this an L2 cmd?
        try {
          known = pipeline.parseCmd(cname, args);
        }
        catch (L2NativeException e) {
          // System.err.println(e);
          // parseCmdJNI catches C++ errors thrown by L2, prints the msg
          // to the L2Tools cmd line 
          // and does a throwNew, which is caught here
          // if it is not caught here, there will be an asynchronous call
          // to Stanley which will cause the Scenario Mgr to invalidate the run
        }
        if (! known) {
          System.out.println("Didn't understand command `" + cname + "'; try help");
        }
      }
    }
  }

  private void showNewEngineArgs ( ) {
    System.out.println("  newEngine CBFS\n    max_candidate_classes_returned - (0-100)\n    max_candidates_returned - (1-1000)\n    max_candidates_searched - (100-100000)\n    max_cutoff_weight - (1-1000)\n    max_history_cutoff - (0-100)\n    max_trajectories_tracked - (1-100)\n    progress_cmd_type - (min | full)\n    fc_cmd_type - (extend | prune-search | find-fresh)");
    System.out.println("  newEngine COVER\n    max_candidate_rank - (1-1000)\n    dummy1 - 100\n    dummy2 - 100\n    max_history_cutoff - (0-100)\n    max_trajectories_tracked - (1-100)\n    progress_cmd_type - (min | full)\n    fc_cmd_type - (extend | prune-search | find-fresh)");

  }

  // this causes repaint problems when windows are redrawn
  private boolean deleteHistoryTables () {
    // if historyTables exist, kill them and start new ones
    // to prevent messy errors
    int reloadHistoryTableCount = 0;
    for (int i = 0, n = historyTableArray.size(); i < n; i++) {
      HistoryTable historyTable = (HistoryTable) historyTableArray.get( i);
      System.err.println( "deleteHistoryTables i " + i);
      try {
        reloadHistoryTableCount += 1;
        // window must be exposed to get location
        historyTable.show();
        historyTableLocationArray.set( i, historyTable.getLocationOnScreen());
        historyTableSizeArray.set( i, historyTable.getSize());
        // historyTable must be disposed before its child frames can be
        historyTable.dispose();
        historyTable.closeHistoryTable();
        Vector justificationFrames = historyTable.getJustificationFrames();
        for (int j = 0, nj = justificationFrames.size(); j < nj; j++) {
          ((JFrame) justificationFrames.elementAt( j)).dispose();
        }
      } catch (Exception e) {
        // historyTable pointer not nulled, if user exits history table
        // and restarts it
       System.err.println( "deleteHistoryTables catch i " + i + " error " + e);
       historyTableArray.set( i, null);
       reloadHistoryTableCount -= 1;
      }
      System.err.println( "deleteHistoryTables reloadHistoryTableCount " +
                          reloadHistoryTableCount + " i " + i + " numT " + n);
    }
    return (reloadHistoryTableCount > 0);
  } // end deleteHistoryTables

  // this causes repaint problems when windows are redrawn
  private void createHistoryTablesAtLocation () {
    for (int i = 0, n = historyTableArray.size(); i < n; i++) {
      if ((HistoryTable) historyTableArray.get( i) != null) {
        HistoryTable historyTable = (HistoryTable) engineManager.newHistoryTableTool(0);
        historyTableArray.set( i, historyTable);
        // maintain window location & dimensions
        System.err.println( "createHistoryTablesAtLocation loc " +
                            historyTableLocationArray.get( i));
        historyTable.setLocation( (Point) historyTableLocationArray.get( i));
        System.err.println( "createHistoryTablesAtLocation size " +
                            historyTableSizeArray.get( i));
        historyTable.setSize( (Dimension) historyTableSizeArray.get( i));
        historyTable.setVisible( true);
      }
    }
  } // end createHistoryTablesAtLocation


}




