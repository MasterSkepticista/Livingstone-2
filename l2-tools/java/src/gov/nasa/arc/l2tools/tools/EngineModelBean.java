//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

package gov.nasa.arc.l2tools.tools;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
import java.util.Vector;
import javax.swing.DefaultListModel;
import javax.swing.ListModel;
import java.util.List;

import livdll.*;
import gov.nasa.arc.l2tools.tools.Candidate;

public class EngineModelBean {
    public int getSelectedTimeStep(){ return selectedTimeStep; }

    public void setSelectedTimeStep(int selectedTimeStep){
        int oldSelectedTimeStep = getSelectedTimeStep();
        this.selectedTimeStep = selectedTimeStep;
        propertyChangeSupport.firePropertyChange("selectedTimeStep",
            new Integer(oldSelectedTimeStep),
            new Integer(selectedTimeStep));
    }

    public Candidate getSelectedCandidate() {return selectedCandidate;}

    public void setSelectedCandidate(Candidate selectedCandidate){
        Candidate oldSelectedCandidate = getSelectedCandidate();
        this.selectedCandidate = selectedCandidate;
        propertyChangeSupport.firePropertyChange("selectedCandidate",
                                                 oldSelectedCandidate,
                                                 selectedCandidate);
    }

  // added by will taylor 19sep02 to allow StanleyAdapter.singleStepCmd to 
  // refresh the History Table
  public void refreshHistoryTable() {
    // cannot use setSelectedCandidate, since the candidate has not changed
    propertyChangeSupport.firePropertyChange( "selectedCandidate", true, false);
  }

    public String getSearchTermination(){ return searchTermination; }

    public void setSearchTermination(String searchTermination){
        String oldSearchTermination = getSearchTermination();
	this.searchTermination = searchTermination;
        propertyChangeSupport.firePropertyChange("searchTermination",
                                                 oldSearchTermination,
                                                 searchTermination);
    }

    public String getType(){ return type; }

    public int getStartTimeStep(){ return startTimeStep; }

    public void setStartTimeStep(int startTimeStep){
        int oldStartTimeStep = getStartTimeStep();
        this.startTimeStep = startTimeStep;
        // System.err.println("EngModelBean: in setStartTimeStep oldStartTimeStep " + oldStartTimeStep + " startTimeStep " + startTimeStep);
        propertyChangeSupport.firePropertyChange("startTimeStep",
            new Integer(oldStartTimeStep),
            new Integer(startTimeStep));
        // will taylor 06/19/01
	if (oldStartTimeStep == selectedTimeStep)
            setSelectedTimeStep(startTimeStep);
    }

    public Candidate[] getCandidates() { return candidates; }

    public void setCandidates(Candidate[] candidates) throws PropertyVetoException{
        Candidate[] oldCandidates = getCandidates();
        this.candidates = candidates;
        propertyChangeSupport.firePropertyChange("candidates", oldCandidates,
                                                 candidates);
    }

    public Candidate[] getCandidateClasses() { return candidateClasses; }

    public void setCandidateClasses(Candidate[] candidates) {
      Candidate[] oldCandidates = getCandidateClasses();
      this.candidateClasses = candidates;
      // no property change firing needed --
      // candidateClasses "piggy-backs" on candidates
//       propertyChangeSupport.firePropertyChange("candidateClasses",
//                                                oldCandidates, candidates);
    }

    
    //Added by RG
    public Vector getDiscrepancyAssignments() {return discrepancys;}
    
    public void setDiscrepancyAssignments(Vector assignments){

      for(int i =0; i < assignments.size(); i++)
          if(!(assignments.elementAt(i) instanceof Discrepancy)) return;

      this.discrepancys = assignments; 
    }
    
    
    public void addPropertyChangeListener(PropertyChangeListener l){
        propertyChangeSupport.addPropertyChangeListener(l);
    }

    public void removePropertyChangeListener(PropertyChangeListener l){
        propertyChangeSupport.removePropertyChangeListener(l);
    }

    public int getCurrentTimeStep(){ return currentTimeStep; }

    public void setCurrentTimeStep(int currentTimeStep){
        int oldCurrentTimeStep = getCurrentTimeStep();
        this.currentTimeStep = currentTimeStep;
        propertyChangeSupport.firePropertyChange("currentTimeStep",
            new Integer(oldCurrentTimeStep),
            new Integer(currentTimeStep));
	// Stephen Wragg added this 10/23/00
	if(oldCurrentTimeStep == selectedTimeStep) setSelectedTimeStep(currentTimeStep);
    }

    public void setType(String type){
        java.lang.String oldType = getType();
        this.type = type;
        propertyChangeSupport.firePropertyChange("type", oldType, type);
    }

    public DefaultListModel getRecentAssignments(){ return recentAssignments; }

    public void setRecentAssignments(DefaultListModel recentAssignments){
        ListModel oldRecentAssignments = getRecentAssignments();
        this.recentAssignments = recentAssignments;
        propertyChangeSupport.firePropertyChange("recentAssignments", oldRecentAssignments, recentAssignments);
    }

    public AttributeAssignment getLastProgress(){ return lastProgress; }

    public void setLastProgress(AttributeAssignment lastProgress){
        // AttributeAssignment oldLastProgress = getLastProgress(); it won't update if there the same and that causes a bug with stanley
        AttributeAssignment oldLastProgress = null;
        this.lastProgress = lastProgress;
        propertyChangeSupport.firePropertyChange("lastProgress",
                                                 oldLastProgress, lastProgress);
    }

    public void setLastProgressPostTime (AttributeAssignment lastProgress){
        // do this for HistoryTable.propertyChange which updates the history
        // table current time slice - wmt
        AttributeAssignment oldLastProgress = null;
        propertyChangeSupport.firePropertyChange("lastProgressPostTime",
                                                 oldLastProgress, lastProgress);
    }

    public String getModel(){ return model; }

    public void setModel(String model){
        java.lang.String oldModel = getModel();
        this.model = model;
        propertyChangeSupport.firePropertyChange("model", oldModel, model);
    }

    public String getState(){ return state; }

    public void setState(String state){
        java.lang.String oldState = getState();
        this.state = state;
        propertyChangeSupport.firePropertyChange("state", oldState, state);
    }

    public Attribute[] getAttributes(){ return attributes; }

    public void setAttributes(Attribute[] attributes){
        gov.nasa.arc.l2tools.tools.Attribute[] oldAttributes = getAttributes();
        this.attributes = attributes;
        propertyChangeSupport.firePropertyChange("attributes", oldAttributes, attributes);
    }

    public java.util.SortedSet getAttributeNames(){ return attributeNames; }

    public void setAttributeNames(java.util.SortedSet attributeNames) {
        java.util.SortedSet oldAttributeNames = getAttributeNames();
        this.attributeNames = attributeNames;
        propertyChangeSupport.firePropertyChange("attributeNames", oldAttributeNames, attributeNames);
    }

    public int getEndTimeStep(){ return endTimeStep; }

    public void setEndTimeStep(int endTimeStep){
        int oldEndTimeStep = getEndTimeStep();
        this.endTimeStep = endTimeStep;
        propertyChangeSupport.firePropertyChange("endTimeStep",
            new Integer(oldEndTimeStep),
            new Integer(endTimeStep));
    }

  public void setEnableGUIUpdateOn() {
    this.enableGUIUpdate = true;
  }

  public void setEnableGUIUpdateOff() {
    this.enableGUIUpdate = false;
  }

  public boolean getEnableGUIUpdate() {
    return enableGUIUpdate;
  }

  public void setEnableCandMgrOnlyUpdateOn() {
    this.enableCandMgrOnlyUpdate = true;
  }
 
  public void setEnableCandMgrOnlyUpdateOff() {
    this.enableCandMgrOnlyUpdate = false;
  }

  public boolean getEnableCandMgrOnlyUpdate() {
    return enableCandMgrOnlyUpdate;
  }

    private int selectedTimeStep;
    private Candidate selectedCandidate;
    private String searchTermination;
    private String type;
    private int startTimeStep;
    /**
     *@link aggregation
     *     @associates <{Candidate}>
     */
    private Candidate[] candidates;
    private Candidate[] candidateClasses;
    private Vector discrepancys;

    private PropertyChangeSupport propertyChangeSupport = new java.beans.PropertyChangeSupport(this);
    private int currentTimeStep;

    /**
     * A list holding AttributeAssignment's that represent the assign commands executed since the last progress command. 
     */
    private DefaultListModel recentAssignments;

    /**
     * A bound property that holds an AttributeAssignment representing the most recent progress command. 
     */
    private AttributeAssignment lastProgress;
    private String model;
    private String state;
    private int endTimeStep;

    /**
     * Array of Attribute objects in no particular order.    Changes after the model is loaded. 
     */
    private Attribute[] attributes;

    /**
     * Holds a SortedSet of strings naming the attributes of the currently loaded model.  Names are sorted alphabetically.  Changes after the model is loaded.
     */
    private java.util.SortedSet attributeNames;

    // enable updating of GUI tools, e.g. Stanley, Candidate Mgr, History Table
    // needed for handling Scenario Mgr warp running -- will taylor 02aug01
    private boolean enableGUIUpdate;

    // enable updating of only Candidate Mgr GUI tool
    // needed for handling checkpoint restore -- will taylor 02aug01
    private boolean enableCandMgrOnlyUpdate;

}



