//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

package gov.nasa.arc.l2tools.tools;

import java.util.*;
import java.io.File;
import javax.swing.DefaultListModel;
import javax.swing.ListModel;
import livdll.*; 

public class DataModel extends EngineModelBean implements EngineListener {
    
    private ScenarioInterface pipeline = null;
    
    public DataModel() {
        LivingstoneEngineAdapter p = new LivingstoneEngineAdapter();
        setPipeline(p);
        setRecentAssignments(new DefaultListModel());
        initBean();
        p.addEngineListener(this);
    }
    
    private void initBean() {
        setType("none");
        setStartTimeStep(0);
        // reset time step end so that history table does not start
        // off with too many columns
        setEndTimeStep(1);
        try {
            setCandidateClasses(new Candidate[0]);
            setDiscrepancyAssignments(new Vector());  //Added By RG
            setCandidates(new Candidate[0]); // fires candidates property change
        } catch(java.beans.PropertyVetoException e) {
            System.out.println(e);
        }
        setSelectedCandidate(null);
        setCurrentTimeStep(1);
        setSelectedTimeStep(1);
        setModel("none");
        setState("stopped");
        setSearchTermination(" ");
        getRecentAssignments().clear();
        if(pipeline != null) pipeline.cleanup();
        setEnableGUIUpdateOn();
        setEnableCandMgrOnlyUpdateOff();
    }
    
    public void cleanup() {
        if(pipeline != null) pipeline.cleanup();
    }
    
    public ScenarioInterface getPipeline(){
        return pipeline;
    }
    
    public void setPipeline(ScenarioInterface pipeline){
        this.pipeline = pipeline;
    }
    
    public void echoNewEngine(Object source, String search_method) {
        initBean(); 
        setState("idle");
        setType(search_method);
    }
    
    public void echoDestroyEngine(Object source) {
        setState("stopped");
        setType("none");
        setModel("none");
    }
    
    public void echoLoadModel(Object source, String fileName, SortedSet attributeNames) {
        setModel(fileName);
        setAttributeNames(attributeNames);
    }
    
    public void echoCommand(Object source, String progress) {
        try {
            int t[] = pipeline.getHistoryStartStop();
            
            // Update the lastProgress and recentAssignments properties
            // do this prior to setCurrentTimeStep for
            // StanleyAdapter.propertyChange which issues gotProgress
            setLastProgress(new AttributeAssignment(Integer.toString(t[1])+"#"+progress));
            getRecentAssignments().clear();
            
      /* Update the times */
            if (getStartTimeStep() != t[0]) setStartTimeStep(t[0]);
            if (getEndTimeStep() != t[1]) setEndTimeStep(t[1]);
            if (getCurrentTimeStep() != t[1]) setCurrentTimeStep(t[1]);
            
            // do this after setCurrentTimeStep for
            // HistoryTable.propertyChange which updates the history table current time slice
            // - wmt
            setLastProgressPostTime(new AttributeAssignment(Integer.toString(t[1])+"#"+progress));
            
        } catch(L2NativeException e) {
            System.out.println(e);
        }
    }
    
    public void updateTimes() {
        try {
            int t[] = pipeline.getHistoryStartStop();
            setStartTimeStep(t[0]);
            setEndTimeStep(t[1]);
            setCurrentTimeStep(t[1]);
        } catch(L2NativeException e) {
            System.out.println(e);
        }
    }
    
    
    public void echoMonitor(Object source, String assignment) {
        try {
            int t[] = pipeline.getHistoryStartStop();
            
            // Update the times (why are we bothering?)
            // Was missing - shirley
            if (getEndTimeStep() != t[1]) setEndTimeStep(t[1]);
            // progress shouldn't change the current timestep
            // if(getCurrentTimeStep() != t[1]) setCurrentTimeStep(t[1]);
            if(getStartTimeStep() != t[0]) setStartTimeStep(t[0]);
            
            // Update the recent assignments
            // Push onto the beginning of the list
            getRecentAssignments().add(0,new AttributeAssignment(Integer.toString(t[1])+"#"+assignment));
        } catch(L2NativeException e) {
            System.out.println(e);
        }
    }
    
    public void echoPropagate(Object source, boolean consistent) {}
    
    public void echoFindCandidates(Object source) {
        // "searching" is hard coded into the candidate manager.
        setState("searching");
        setSearchTermination(" ");
    /* I used to do this to clear the candidateManager, but now I don't like it.
    try {
      setCandidates(new Candidate[0]);
    } catch(java.beans.PropertyVetoException e) {
      System.out.println(e);
    }
     */
    }

  // LivingstoneEngineAdapter.findCandidates calls this
    public void replyFoundCandidates(Object source, Candidate[] candidates,
                                     Candidate[] candidateClasses,
                                     Vector assignments,
                                     String searchTermination) {
        setState("idle");
        try {
            // this next call to setSelectedCandidate causes the History Table to
            // install the zeroth candidates values, after fc returns more than
            // one candidate, and before the candidate mgr has make a selection
            // comment it out - wmt
            //setSelectedCandidate(null);
            setDiscrepancyAssignments(assignments); //Added by RG
            setCandidateClasses( candidateClasses);
            setCandidates( candidates); // fires property change for Candidate Mgr
            if (candidates.length == 1) {
              setSelectedCandidate( candidates[0]);
            }
        } catch(java.beans.PropertyVetoException e) {
            System.out.println(e);
        }
        setSearchTermination(searchTermination); 
    }
    
}
