//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

package gov.nasa.arc.l2tools.tools;


import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.DefaultMutableTreeNode;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.Enumeration;
import javax.swing.tree.TreePath;
import javax.swing.JTree;
import livdll.*;

public class State implements java.io.Serializable {

  private transient Vector growingCacheOfAssignments = new Vector();
  private transient StateTreeNode rootNode = null;
  //  private LivingstoneCorba.Assignment[] livingstoneAssignments;
  private String name = "no name";
  private int time;

  public State(String name, int time) {
    this.name = name;
    this.time = time;
  }

  public State(String name, int time, AttributeAssignment[] assignments) {
    this.name = name;
    this.time = time;
    for(int i = 0; i < assignments.length; i++)
      addAssignmentToCache(assignments[i]);
  }

  public void setRootNode(StateTreeNode r) { rootNode = r; }

  public int getTime() { return time; }

  public String toString() { return name; }

  //  public LivingstoneCorba.Assignment[] getLivingstoneAssignments() { return livingstoneAssignments; }

  public synchronized DefaultMutableTreeNode getRootNode() { return rootNode; }

  public synchronized void addAssignmentToCache(AttributeAssignment assignment) {
    growingCacheOfAssignments.add(assignment);
  }

  public synchronized void flushCache(final JTree tree, final DefaultTreeModel treeModel, String fullNameOfComponentToOpen) {
    /*
    if(growingCacheOfAssignments.size() > 0) {
      livingstoneAssignments = new LivingstoneCorba.Assignment[growingCacheOfAssignments.size()];
      for(int i = 0; i < growingCacheOfAssignments.size(); i++) {
	livingstoneAssignments[i] = ((AttributeAssignment)growingCacheOfAssignments.elementAt(i)).getLivingstoneCorbaAssignment();
      }
      growingCacheOfAssignments = new Vector();
    }
    */
    if(fullNameOfComponentToOpen!=null) fullNameOfComponentToOpen = fullNameOfComponentToOpen.substring(0,fullNameOfComponentToOpen.lastIndexOf("."));
    final String open = fullNameOfComponentToOpen;
    
    Thread thread = new Thread(new Runnable() {
      public void run() {
	TreePath path = null;
	//	LivingstoneCorba.Assignment assignment = null;
	//	for(int i = 0; i < livingstoneAssignments.length; i++) {
	//	  assignment = (LivingstoneCorba.Assignment)livingstoneAssignments[i];
	Enumeration enum = growingCacheOfAssignments.elements();
	AttributeAssignment assignment = null;
	while(enum.hasMoreElements()) {
	  assignment = (AttributeAssignment)enum.nextElement();
	  StateTreeNode node  = rootNode.addAssignment(treeModel, new StringTokenizer(assignment.getName()+"="+assignment.getValue(), "."));
	  if(open!=null && path==null && assignment.getName().startsWith(open)) {
	    path = new TreePath(treeModel.getPathToRoot(node));
	    path = path.getParentPath();
	  }
	}
	if(path == null) path = new TreePath(treeModel.getRoot());
	if(open != null) {
	  enum = tree.getExpandedDescendants(new TreePath(treeModel.getRoot()));
	  if(enum != null) {
	    while(enum.hasMoreElements())
	      tree.collapsePath((TreePath)enum.nextElement());
	  }
	  tree.expandPath(path);
	}
      }
    });
    thread.start();
  }


}                          
