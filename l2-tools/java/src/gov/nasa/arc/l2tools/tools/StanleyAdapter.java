//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

package gov.nasa.arc.l2tools.tools;

import java.util.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
// import java.io.IOException;
import javax.swing.DefaultListModel;
import LivingstoneCorba.*;
import livdll.*;
import java.io.*;

public class StanleyAdapter extends LivingstoneCorba._LivingstoneCommandLineImplBase implements PropertyChangeListener, Tool {

  private DataModel model;
  // one tool should not contain another, but stanley is dependent on this.
  private CommandLine commandLine;
  private Vector listeners = new Vector();
  public final static short JNI_COMMAND_ERROR = 1;
  private int lastProgressTime = -1;
  private boolean stanleyViewerStartedP = false;

  public StanleyAdapter(DataModel model, CommandLine commandLine) {
    super();
    this.model = model;
    this.commandLine = commandLine;
    model.addPropertyChangeListener(this);
    model.getRecentAssignments().addListDataListener(new MyListDataListener());
  }
  
  class MyListDataListener implements javax.swing.event.ListDataListener {
    // Sent when the contents of the list has changed in a way that's too complex to characterize with the previous methods.
    public void contentsChanged(javax.swing.event.ListDataEvent e) {}
    // Sent after the indices in the index0,index1 interval have been inserted in the data model.
    public void intervalAdded(javax.swing.event.ListDataEvent e) {
      DefaultListModel ra = model.getRecentAssignments();
      if(ra.getSize() > 0) {
	AttributeAssignment aa = (AttributeAssignment)ra.getElementAt(0);
	gotAssignment(aa.getName()+"="+aa.getValue());
      }
    }
    // Sent after the indices in the index0,index1 interval have been removed from the data model.
    public void intervalRemoved(javax.swing.event.ListDataEvent e) {}
  }

  protected void sendAsynchronousMsg( String msg) {
//     System.out.println("\n\n******* sendAsynchronousMsg *********");
//     try {
//       throw new Exception();
//     } catch (Exception e) { e.printStackTrace(); }

    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.asynchronousMsg(JNI_COMMAND_ERROR, msg);
    }
  }

  protected void gotAssignment(String monitor) {
    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.gotAssignment(monitor);
    }
  } 

  protected void gotProgress(String command) {
    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.gotProgress(command);
    }
  } 

  public void propertyChange(PropertyChangeEvent evt) {
//     System.err.println("\n\nStanAdap.propertyChange: evt " + evt.getPropertyName());
//     System.err.println("  oldValue" + evt.getOldValue() + " newValue " + evt.getNewValue());
//     try {
//       throw new Exception();
//     } catch (Exception e) { e.printStackTrace(); }

    if (model.getEnableCandMgrOnlyUpdate())
      return;

    if (evt.getPropertyName().equals("selectedTimeStep") && (model != null) &&
        model.getEnableGUIUpdate()) {
      boolean validHistory = true;
      try {
        int t[] = model.getPipeline().getHistoryStartStop();
        if ((t[0] == 0) && (t[1] == 0)) {
          validHistory = false;
        }
      } catch (Exception e) {
        String msg = e.getMessage();
        System.err.println( msg);
        sendAsynchronousMsg( msg);
      }
      // do not call sendNewState if there is no history

//       System.err.println("StanAdap: validHistory " + validHistory + " lastProgressTime " + lastProgressTime + " SelectedTimeStep " + model.getSelectedTimeStep());
//       try {
//         throw new Exception();
//       } catch (Exception e) { e.printStackTrace(); }

      if ((lastProgressTime == model.getSelectedTimeStep()) ||
          (validHistory == false)) {
      	lastProgressTime = -1;
      	return;
      }
      try {
        sendNewState();
      } catch (Exception e) {
        String msg = e.getMessage();
        System.err.println( msg);
        sendAsynchronousMsg( msg);
      }

    } else if (evt.getPropertyName().equals("candidates") && (model != null)) {
      lastProgressTime = -1;
      Candidate[] cc = model.getCandidates();
      Enumeration enum = listeners.elements();
      while(enum.hasMoreElements()) {
        LivingstoneCorba.LivingstoneEventListener ll =
          (LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
        ll.gotCandidates(cc.length);
      }
  
    } else if(evt.getPropertyName().equals("lastProgress") && model != null) {
      AttributeAssignment aa = model.getLastProgress();
      lastProgressTime = aa.getTime();
      if ("".equalsIgnoreCase(aa.getName())) {
        // idle progress
        gotProgress("");
      } else {
        gotProgress(aa.getName()+"="+aa.getValue());
      }

    } else if(evt.getPropertyName().equals("selectedCandidate") && (model != null) &&
              model.getEnableGUIUpdate()) {
      try {
	if(model.getSelectedCandidate() != null) {
          sendNewState();
        }
      } catch(Exception e) {
	System.out.println(e);
      }

    }
  }

  public void setModel(DataModel model) {
    this.model = model;
  }

  public DataModel getModel() { return model; }

  public java.awt.Container getContainer() { return null; }

  public void release() {}

  public void addLivingstoneEventListener(LivingstoneCorba.LivingstoneEventListener listener) throws LivingstoneCorba.LivingstoneException {
    if(!listeners.contains(listener)) listeners.add(listener);
  }

  public void removeLivingstoneEventListener(LivingstoneCorba.LivingstoneEventListener listener) throws LivingstoneCorba.LivingstoneException {
    listeners.remove(listener);
  }

  public void clearLivingstoneEventListeners() {
    listeners.clear();
  }

  public synchronized void command(String command) {
    // System.out.println("StanleyAdapter.command("+command+")");
    if (model.getPipeline() != null) {
      try {
        // Clean up command
        command = command.trim();
	
        // separate the command's name from the arguments
        String[] pair = LivingstoneEngine2.breakAtSubstring(command," ");
        dispatchCommand(pair[0].trim(),pair[1].trim());
      } catch(IllegalAccessError e) {
        System.out.println(e);
      }
    }
  }
  
  public String getHistoryTimes() throws LivingstoneCorba.LivingstoneException {
    // return to Stanley the sames values as the L2 command line cmd `times'
    String startStopString = new String("");
    try {
      int [] startStopArray = model.getPipeline().getHistoryStartStop();
      startStopString = new String(startStopArray[0] + " " + startStopArray[1]);
      // System.err.println("getHistoryTimes: start " + startStopArray[0] + " stop " + startStopArray[1] + " startStopString " + startStopString);
    } catch (L2NativeException e) {
      // msg is ouptut to skunkworks cmd line by throw_error in JNI methods
      String msg = e.getMessage();
      sendAsynchronousMsg( msg);
    }
    return startStopString;
  }

  public void enableGUIUpdate() {
    model.setEnableGUIUpdateOn();
  }

  public void disableGUIUpdate() {
    model.setEnableGUIUpdateOff();
  }

  public synchronized void warpCommands(String commands) {
    // execute L2 cmds without Skunkworks/Stanley updates or interaction
    if (model.getPipeline() != null) {
      System.out.println("StanleyAdapter.warpCommands ...");
      System.out.print("======> ");
      try {
        model.getPipeline().execWarpCommands( commands);
        // disable all Stanley & History Table updates during time change --
        // let Candidate Mgr selection do it
        model.setEnableCandMgrOnlyUpdateOn();
        model.updateTimes();
        model.setEnableCandMgrOnlyUpdateOff();
        // update History Table time slices
        model.setLastProgressPostTime( model.getLastProgress());
        refreshStanleyAndHistoryTable();
      } catch(L2NativeException e) {
        String msg = e.getMessage();
        System.err.println( msg);
        sendAsynchronousMsg( msg);
      }
    }
  }

  public synchronized void getEngine( String search_method,
                                      int max_candidate_classes_returned,
                                      int max_candidates_returned,
                                      int max_candidates_searched,
                                      int max_cutoff_weight, int max_history_cutoff,
                                      int max_trajectories_tracked,
                                      String progress_cmd_type, String fc_cmd_type) {
      try {
	  model.getPipeline().newEngine(this, search_method,
                                        max_candidate_classes_returned,
                                        max_candidates_returned,
                                        max_candidates_searched,
                                        max_cutoff_weight, max_history_cutoff,
                                        max_trajectories_tracked,
                                        progress_cmd_type, fc_cmd_type);
      } catch(L2NativeException e) {
        String msg = e.getMessage();
        System.err.println( msg);
        sendAsynchronousMsg( msg);
      } catch(IndexOutOfBoundsException e) {
	  System.out.println(e.getMessage());
      }
  }

  protected void dispatchCommand(String cname, String args) {
    try {
      if ("refresh".equalsIgnoreCase(cname)) {
        // Skunkworks cmd line cmd
        System.out.println("StanleyAdapter.command(" + cname + " " + args + ")");
	refreshStanleyAndHistoryTable();
      } else if ("restore".equalsIgnoreCase(cname)) {
        System.out.println("StanleyAdapter.command(" + cname + " " + args + ")");
        // restore L2 state from checkpoint
        // returns false if no checkpoint is defined
        if (model.getPipeline().restoreCheckpoint(this, args)) {
          model.cleanup();
          // pass on to general Skunkworks cmds to
          // update Candidate Mgr and History Table
          commandLine.dispatchCommand("restore", args);
        }
      } else if ("truncate".equalsIgnoreCase(cname)) {
        System.out.println("StanleyAdapter.command(" + cname + " " + args + ")");
	StringTokenizer s3 = new StringTokenizer(args, " ");
	if (s3.countTokens() != 1) {
          System.err.println("truncate args not valid");
          System.err.println("truncate <horizon-time>");
        } else {
          // truncate L2 state prior to args value
          model.getPipeline().parseCmd(cname, args);
          model.cleanup();
          // pass on to general Skunkworks cmds to
          // update Candidate Mgr and History Table
          commandLine.dispatchCommand("truncate", args);
        }
      } else if ("singleStep".equalsIgnoreCase(cname)) {
        // Stanley scenario mgr cmd
        System.out.println("StanleyAdapter.command(" + cname + " " + args + ")");
        refreshStanleyAndHistoryTable();
      } else if ("stanleyViewer".equalsIgnoreCase(cname)) {
        System.out.println("StanleyAdapter.command(" + cname + " " + args + ")");
        // test Stanley viewer cmds
	StringTokenizer s = new StringTokenizer(args," ");
	int num_args = s.countTokens();
        String viewer_cmd = new String(" ");
        if (num_args > 0) 
          viewer_cmd = s.nextToken();
        String dummy = new String("null");
        if ((stanleyViewerStartedP == false) & (num_args > 0)) {
          String msg = "Stanley Viewer does not exist -- use `stanleyViewer'";
          System.err.println( msg);
          sendAsynchronousMsg( msg);
        }
        if (num_args == 0) {
          // start Stanley in viewer mode
          System.out.println("Starting Stanley in viewer mode");
          String stanleyRoot = new String("null");
          try {
            // run a command
            String outlist[] = runCommand("printenv STANLEY_ROOT");
            // display its output
            // for (int i = 0; i < outlist.length; i++)
            //   System.out.println("i " + i + " " + outlist[i]);
            stanleyRoot = outlist[0];
          }
          catch (IOException e) {
            System.err.println(e);
          }
          // System.out.println("stanleyRoot " + stanleyRoot);
          if (! "null".equalsIgnoreCase(stanleyRoot)) {
            final String cmd = stanleyRoot.concat("/interface/RUN-STANLEY-FROM-L2TOOLS.csh -viewer");
            // System.out.println("cmd " + cmd);
            Thread thread = new Thread(new Runnable() {
                public void run() {
                  try {
                    runCommand(cmd);
                  } catch(java.io.IOException e) {
                    System.out.println(e);
                  }
                }
              });
            thread.start();
            stanleyViewerStartedP = true;
          } else {
            System.out.println("STANLEY_ROOT not found");
          }
        } else if (num_args == 1) {
          // getWorkSpaces
          // getModules
          // modelState
          if ("getWorkSpaces".equalsIgnoreCase(viewer_cmd)) {
            getWorkSpaces();
          } else if ("getModules".equalsIgnoreCase(viewer_cmd)) {
            getModules();
          } else if ("modelState".equalsIgnoreCase(viewer_cmd)) {
            initializeL2ModelState( model.getModel());
          } else {
            System.out.println("Invalid stanleyViewer cmd: " + args);
          }
        } else if (num_args == 2) {
          // loadWorkSpace $workspace 
          // loadModule $moduleName
          // getInstances {terminal attribute module component}
          if ("loadWorkSpace".equalsIgnoreCase(viewer_cmd)) {
            loadWorkSpace(s.nextToken());
          } else if ("loadModule".equalsIgnoreCase(viewer_cmd)) {
            loadModule(s.nextToken());
          } else if ("getInstances".equalsIgnoreCase(viewer_cmd)) {
            getInstances(s.nextToken(), dummy);
          } else {
            System.out.println("Invalid stanleyViewer cmd: " + args);
          }
        } else if (num_args == 3) {
          // getInstances mode $componentInstanceName
          // metaDot {terminal attribute} $instanceName
          if ("getInstances".equalsIgnoreCase(viewer_cmd)) {
            getInstances(s.nextToken(), s.nextToken());
          } else if ("metaDot".equalsIgnoreCase(viewer_cmd)) {
            metaDot(s.nextToken(), s.nextToken(), dummy, dummy);
          } else {
            System.out.println("Invalid stanleyViewer cmd: " + args);
          }
        } else if (num_args == 4) {
          // metaDot {component module} $instanceName $dialogType 
          metaDot(s.nextToken(), s.nextToken(), s.nextToken(), dummy);
        } else if (num_args == 5) {
          // metaDot component $instanceName $dialogType $modeName
          metaDot(s.nextToken(), s.nextToken(), s.nextToken(), s.nextToken());
        } else {
          System.out.println("Invalid stanleyViewer cmd: " + args);
        }
      } else {
        // System.err.println(" Stanley Adapter cannot handle this cmd");
        // pass on to general Skunkworks cmds and L2 cmds
        commandLine.dispatchCommand(cname, args);
      }
    } catch (L2NativeException e) {
      // msg is ouptut to skunkworks cmd line by throw_error in JNI methods
      String msg = e.getMessage();
      sendAsynchronousMsg( msg);
    } catch(Exception e) {
      // for other exceptions, output to skunkworks cmd line
      String msg = e.getMessage();
      System.err.println( msg);
      sendAsynchronousMsg( msg);
    }
  }

    // Start Stanley Viewer Methods

  public String[] getWorkSpaces() {
    Enumeration enum = listeners.elements();
    String workspaceList = new String(" ");
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      workspaceList = ll.getWorkSpaces();
    }
    // System.out.println("getWorkSpaces: " + workspaceList);
    StringTokenizer stringTokens = new StringTokenizer(workspaceList, " ");
    int num_workspaces = stringTokens.countTokens();
    String[] workspaceArray = new String[num_workspaces];
    for (int i = 0; i < num_workspaces; i++) {
      workspaceArray[i] = stringTokens.nextToken();
    }
    return workspaceArray;
  } 

  public String[] getModules() {
    Enumeration enum = listeners.elements();
    String moduleList = new String(" ");
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      moduleList = ll.getModules();
    }
    // System.out.println("getModules: " + moduleList);
    StringTokenizer stringTokens = new StringTokenizer(moduleList, " ");
    int num_modules = stringTokens.countTokens();
    String[] moduleArray = new String[num_modules];
    for (int i = 0; i < num_modules; i++) {
      moduleArray[i] = stringTokens.nextToken();
    }
    return moduleArray;
  } 

  public void initializeL2ModelState( String modelFilename) {
    String moduleName = new String(" ");
    String msg;
    // System.err.println("StanleyAdapter.initializeL2ModelState: modelFilename " + modelFilename);
    if ("none".equalsIgnoreCase(modelFilename)) {
      msg = "stanleyViewer initializeL2ModelState failed: there is no loaded L2 model";
      System.err.println( msg);
      sendAsynchronousMsg( msg);
      return;
    }
    int moduleNameStartIndex = modelFilename.lastIndexOf("/");
    int modelFilenameLength = modelFilename.length();
    moduleName = modelFilename.substring( moduleNameStartIndex + 1, modelFilenameLength);
    // System.err.println("StanleyAdapter.initializeL2ModelState: moduleName `" + moduleName + "'");
    // search Stanley's workspaces to find moduleName 
    String[] workspaceArray = getWorkSpaces();
    String[] moduleArray;
    boolean moduleNameFoundP = false;
    workspaceSearch: for (int i = 0; i < workspaceArray.length; i++) {
      // System.err.println("workspaceArray i = " + i + " value = " + workspaceArray[i]);
      loadWorkSpace( workspaceArray[i]);
      moduleArray = getModules();
      for (int j = 0; j < moduleArray.length; j++) {
        // System.err.println("moduleArray j = " + j + " value = `" + moduleArray[j] + "'");
        if (moduleArray[j].equalsIgnoreCase(moduleName)) {
          // we have found the module in the current loaded workspace
          moduleNameFoundP = true;
          // load module and send L2 model state
          // use a separate thread because of time it takes to load the module into Stanley
          final String finalModuleName = new String( moduleName);
            Thread thread = new Thread(new Runnable() {
                public void run() {
                  try {
                    loadModule( finalModuleName);
                    refresh(); 
                  } catch(L2NativeException e) {
                    final String finalMsg = e.getMessage();
                    System.err.println( finalMsg);
                    sendAsynchronousMsg( finalMsg);
                  }
                }
              });
            thread.start();
          break workspaceSearch;
        }
      }
    }
    if (moduleNameFoundP == false) {
      msg = "moduleName `" + moduleName + "' does not exist in the Stanley Viewer's workspaces";
      System.err.println( msg);
      sendAsynchronousMsg( msg);
    }
  } 

  public void loadWorkSpace(String workspace) {
    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.loadWorkSpace(workspace);
    }
  } 

  public void loadModule(String moduleName) {
    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.loadModule(moduleName);
    }
  } 

  public void getInstances(String nodeClassType, String componentInstanceName) {
    Enumeration enum = listeners.elements();
    String instanceList = new String(" ");
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      instanceList = ll.getInstances(nodeClassType, componentInstanceName);
    }
    System.out.println("getInstances: " + instanceList);
  } 

  public void metaDot(String nodeClassType, String instanceName, String dialogType,
                      String modeName ) {
    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.metaDot(nodeClassType, instanceName, dialogType, modeName);
    }
  } 


    // End Stanley Viewer Methods


  public void refresh() throws L2NativeException, IndexOutOfBoundsException {
//     System.out.println("\n\n******* refresh() *********");
    sendNewState(null);
  }

  public void sendNewState() throws L2NativeException, IndexOutOfBoundsException {
//     System.out.println("\n\n******* sendNewState() *********");
    Candidate c = model.getSelectedCandidate();
    if (c == null) {
      Candidate[] candidates = model.getCandidates();
      if(candidates.length > 1)
        sendNewState(candidates[0]);
      else 
        refresh();
    } else {
      sendNewState(c);
    }
  }

  private void sendNewState(Candidate c) throws L2NativeException {
//     System.out.println("\n\n******* sendNewState(Candidate c) *********");
//     try {
//       throw new Exception();
//     } catch (Exception e) { e.printStackTrace(); }
    // Generate the array of Assignments
    AttributeAssignment[][] assns = model.getPipeline().getAttributeAssignments(this,c);
    int s = model.getSelectedTimeStep() - model.getStartTimeStep();
    String msg;
    // int t[] = model.getPipeline().getHistoryStartStop();
    // System.err.println("sendNewState: selectedTime " + model.getSelectedTimeStep() + " startTimeStep " + model.getStartTimeStep() + " endTimeStep " + model.getEndTimeStep() + " historyStartTime " + t[0] + " historyStopTime " + t[1]);
    // System.err.println("sendNewState: s " + s + " assns.length " + assns.length);
    
    if (s < 0 || s > assns.length) {
      msg = "advisory: Stanley selected time step `" + model.getSelectedTimeStep() +
        "' is now out of bounds: `" + model.getStartTimeStep() + " - " +
        model.getEndTimeStep() + "'\nselect in bounds time step with Candidate Mgr";
      System.err.println( msg);
      sendAsynchronousMsg( msg);
      return;
    }
    // System.err.println("sendNewState: assns[s].length ");
    // System.err.println("   0 " + assns[0].length);
    // System.err.println("   1 " + assns[1].length);
    LivingstoneCorba.Assignment[] sd = new LivingstoneCorba.Assignment[assns[s].length];
    for(int i = 0; i < assns[s].length; i++) {
      AttributeAssignment a = assns[s][i];
      sd[i] =  new LivingstoneCorba.Assignment(a.getName(),a.getValue(),s);
    }
    Enumeration enum = listeners.elements();
    while(enum.hasMoreElements()) {
      LivingstoneCorba.LivingstoneEventListener ll =(LivingstoneCorba.LivingstoneEventListener)enum.nextElement();
      ll.newState(model.getSelectedTimeStep()*2f, model.getSelectedTimeStep(), "", new LivingstoneAssignmentReport(sd));
    }
  }

  public void refreshStanleyAndHistoryTable() {
    String msg;
    try {
      boolean consistent = model.getPipeline().propagate(this);
      Candidate selectedCandidate = model.getSelectedCandidate();
      Candidate[] candidateArray = model.getCandidates();
      if ((consistent == true) &&
          (((selectedCandidate  != null) && (candidateArray.length > 1)) ||
           (candidateArray.length == 0) || (candidateArray.length == 1))) {
        sendNewState();
        // refresh History Table
        // cannot use setSelectedCandidate, since the candidate has not changed
        model.refreshHistoryTable();
      } else {
        if (consistent == false) {
          msg = "advisory: Observations inconsistant with current state; run fc \nassignments not returned and history table not refreshed";
          System.err.println( msg);
          sendAsynchronousMsg( msg);
        }
        if ((selectedCandidate == null) && (candidateArray.length > 1)) {
          msg = "advisory: No Candidate Manager candidate has been selected \nassignments not returned and history table not refreshed";
          System.err.println( msg);
          sendAsynchronousMsg( msg);
        }
      }
    } catch (Exception e) {
      msg = e.getMessage();
      System.err.println( msg);
      sendAsynchronousMsg( msg);
    }
  }


  // From JDC Tech-tips February 15, 2000
  static public String[] runCommand(String cmd) throws IOException {

    // set up list to capture command output lines

    ArrayList list = new ArrayList();

    // start command running

    Process proc = Runtime.getRuntime().exec(cmd);

    // get command's output stream and
    // put a buffered reader input stream on it

    InputStream istr = proc.getInputStream();
    BufferedReader br =
    new BufferedReader(new InputStreamReader(istr));

    // read output lines from command

    String str;
    while ((str = br.readLine()) != null)
    list.add(str);

    // wait for command to terminate

    try {
      proc.waitFor();
    }
    catch (InterruptedException e) {
      System.err.println("process was interrupted");
    }

    // check its exit value

    if (proc.exitValue() != 0)
    System.err.println("exit value was non-zero");

    // close stream

    br.close();

    // return list of strings to caller

    return (String[])list.toArray(new String[0]);
  }

}



