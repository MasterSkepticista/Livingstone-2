//
// * See the file "l2-tools/disclaimers-and-notices.txt" for 
// * information on usage and redistribution of this file, 
// * and for a DISCLAIMER OF ALL WARRANTIES.
//
/* Generated by Together */

/* Modified by Shirley (9/18/00) */

package livdll;

import gov.nasa.arc.l2tools.tools.ScenarioInterface;
import gov.nasa.arc.l2tools.tools.LivingstoneEngine2;
import gov.nasa.arc.l2tools.tools.LivingstoneEngine2.JustificationStruct;
//import edu.mit.ai.psg.ui.outliner.*;
import java.util.*;

/** This is basically a struct that contains the public members used in the constructor. */
public class AttributeAssignment implements java.io.Serializable {

  //  private LivingstoneCorba.Assignment scAssignment = new LivingstoneCorba.Assignment();
  private String name;
  private String value; 
  private String noExtValue = ""; 
  private int time;
  private String propString = "";
  private Justification justification = null;

  private AttributeAssignment() {}

  // I need this to support the tree in the candidate viewer.
  public boolean equals(Object obj) {
    if(obj instanceof AttributeAssignment) {
      AttributeAssignment aa = (AttributeAssignment)obj;
      if(name.equals(aa.getName())) return true;
      else return false;
    } else return super.equals(obj);
  }

  // used by Candidate Manager
  public AttributeAssignment(String name, String value) {
    String[] pair = LivingstoneEngine2.breakAtSubstring(name,"#");
    if(pair[1] == "") {
      System.out.println("Got an attribute assignment w/ no time specified.");
      System.out.println(name+"="+value);
      pair[1] = pair[0];
      pair[0] = Integer.toString(Integer.MAX_VALUE);
    }
    this.name = pair[1];
    this.value = value;
    // check for failure at some time before it was last commanded
    if (pair[0].equals("-"))
      this.time = -1;
    else
      this.time = Integer.parseInt(pair[0]);
    propString = Integer.toString(time) + "#" + this.name + "=" + value;
  }                                                   

  // used by Candidate Manager and History Table
  // History Table appends "(e)" or "(i)" to value
  public AttributeAssignment(String name, String value, int time) {
    String[] pair = LivingstoneEngine2.breakAtSubstring(name,"#");
    String longName;
    if(pair[1] != "")
      this.name = pair[1];
    else
      this.name = name;
    this.value = value;
    this.time = time;
    // remove (e) or (i) appended to value for propString 
    int index = value.lastIndexOf("(");
    if (index > 0) {
      value = value.substring(0, index);
    }
    this.noExtValue = value;
    propString = Integer.toString(time) + "#" + this.name + "=" + value;
  }                                                   

  // used by History Table
  public AttributeAssignment(String propString) {
    this.propString = propString;
    String[] pair1 = LivingstoneEngine2.breakAtSubstring(propString,"#");
    if(pair1[1] == "") {
      pair1[1] = pair1[0];
      pair1[0] = Integer.toString(Integer.MAX_VALUE);
    }
    String[] pair2 = LivingstoneEngine2.breakAtSubstring(pair1[1],"=");
    this.name = pair2[0];
    this.value = pair2[1];
    // remove (e) or (i) appended to value for propString 
    int index = value.lastIndexOf("(");
    if (index > 0) {
      value = value.substring(0, index);
    }
    this.noExtValue = value;
    // check for failure at some time before it was last commanded
    if (pair1[0].equals("-"))
      this.time = -1;
    else
      this.time = Integer.parseInt(pair1[0]);
  }

    //  public LivingstoneCorba.Assignment getLivingstoneCorbaAssignment() { return scAssignment; }

  public String getName() { return name; }
  public String getValue() { return value; }
  public String getNoExtValue() { return noExtValue; }
  public int getTime() { return time; }

  /*
    deprecated since it cannot handle 16#test.cb8.currentIn=on
    when current_time = 16
    works only when current_time != time

    used by skunkworks/tools/historyTable/HistoryTable:addPopupMenuItems
  */
  public String getPropString() { 
    // System.err.println("livdll.AttributeAssigment.getPropString() deprecated in favor of getPropString(ScenarioInterface e)" + propString);
    return propString;
  }
    
  /* works for all values of time --
    at current_time = 16
    getPropString() propString 15#test.cb7.cmdIn=noCommand time 15
    getPropString() propString 14#test.cb7.cmdIn=noCommand time 14
    getPropString() propString 13#test.cb7.cmdIn=noCommand time 13
    getPropString() propString test.cb12.currentOut=on time 2147483647
    we want to convert this one
    getPropString() propString 16#test.cb8.currentIn=on time 16
    to
    getPropString() propString test.cb8.currentIn=on time 16

    used by AttributeAssignmentJustificationFrame
  */
  public String getPropString(ScenarioInterface e) {
    try {
      int current_time = e.getHistoryStartStop()[1];
      // System.err.println("livdll.AttributeAssigment.getPropString(ScenarioInterface e) propString " + propString + " current_time " + current_time + " time " + time);
      if (current_time <= time) {
        // System.out.println("               " + name + "=" + noExtValue); 
        return name + "=" + noExtValue;
      } else {
        return propString;
      }
    } catch (L2NativeException err) {
      return propString;
    }
  }


  protected LivingstoneEngine2.PropValueResponse getPropValue(ScenarioInterface pipeline) throws L2NativeException {
    return pipeline.getPropValue(getPropString(pipeline)); 
  }
  public boolean isTrue(ScenarioInterface pipeline) throws L2NativeException {
    return getPropValue(pipeline)==LivingstoneEngine2.PROP_TRUE; }
  public boolean isFalse(ScenarioInterface pipeline) throws L2NativeException {
    return getPropValue(pipeline)==LivingstoneEngine2.PROP_FALSE; }
  public boolean isUnknown(ScenarioInterface pipeline) throws L2NativeException {
    return getPropValue(pipeline)==LivingstoneEngine2.PROP_UNKNOWN; }
  public boolean isRecognized(ScenarioInterface pipeline) throws L2NativeException {
    return getPropValue(pipeline)!=LivingstoneEngine2.PROP_NOT_FOUND;}


  public String toString() { return "<Assignment "+ propString +">"; }

  //
  // Justifications
  //

  public Justification getJustification(ScenarioInterface e) {
    // Respond from cache if it's there
    if (justification!=null) return justification;

    JustificationStruct struct = null;
    String temp = propString;
    try {
      if (time>=e.getHistoryStartStop()[1]) temp = name + "=" + noExtValue;
      struct = e.justificationStruct(temp);
    } catch (L2NativeException err) {}; // silent?
    if (struct==null) {
      System.err.println("\nCouldn't find justification for "+temp);
      System.err.print("======> ");
      return null;
    }

    AttributeAssignment[] pos = new AttributeAssignment[struct.positive_antecedents.size()];
    int max = struct.positive_antecedents.size();
    for (int i=0;i<max;i++) {
      String pname = (String)struct.positive_antecedents.elementAt(i);
      pos[i] = new AttributeAssignment(pname);
    }

    AttributeAssignment[] neg = new AttributeAssignment[struct.negative_antecedents.size()];
    max = struct.negative_antecedents.size();
    for (int i=0;i<max;i++) {
      String pname = (String)struct.negative_antecedents.elementAt(i);
      neg[i] = new AttributeAssignment(pname);
    }
        
    justification = new Justification(pos,neg);
    return justification;
  }

  /* Generate a vector of the AttributeAssignments that immediately
     support this one.  These correspond to the L2 propositions that
     support the proposition corresponding to this assignment.  This
     might include propositions corresponding to this attribute
     holding another value.*/
  public List childPropAttributeAssignments(ScenarioInterface e) {
    List children = new ArrayList();
    Justification j = getJustification(e);
    if (j != null) {
      //    System.out.println("in childPropAttributeAssignments a="+this);
      int posmax = j.getPositiveAntecedentsSize();
      for (int i=0;i<posmax;i++)
        children.add(j.getPositiveAntecedent(i));
      int negmax = j.getNegativeAntecedentsSize();
      for (int i=0;i<negmax;i++)
        children.add(j.getNegativeAntecedent(i));
      //    for (Iterator i=children.iterator();i.hasNext();)
      //      System.out.println("  child["+i+"]="+((AttributeAssignment)i.next()).getPropString(e));
    }
    return children;
  }

  /* Generate a vector of the AttributeAssignments involving other
     attributes that support this one.  This will not include
     Assignments to the same attribute. */
  public List childVarAttributeAssignments(ScenarioInterface e) throws L2NativeException {
    List children = new ArrayList();
    // System.out.println("childVarAttributeAssignments " + this);
    childVarAttributeAssignments1(this,children,e);
    return children;
  }

  /* Helper method for childVarAttributeAssignments.  This has a shot
     at getting the filter right.  When it's looking at a false
     assignment, it looks ahead one level.  If there's an proposition
     at the next level mentioning the same attribute, it's assumed to
     be a true one and the current level is skipped.  Else, the
     current level is the thing added to the list.  This will fail if
     two false propositions to for the same attribute are linked
     together, but that's a pathological case. */
  public List childVarAttributeAssignments1(AttributeAssignment assignment,List result,ScenarioInterface e) 
       throws L2NativeException {
	 String name = assignment.getName();
	 List children = assignment.childPropAttributeAssignments(e);
	 for (Iterator i=children.iterator();i.hasNext();) {
	   AttributeAssignment child = (AttributeAssignment)(i.next());
           // System.out.println("childVarAttributeAssignments1: name " + name + " child " + child.getName());
	   if (name.equals(child.getName())) {
	     if (assignment.isFalse(e)) {
	       result.add(child);
	     } else {
	       childVarAttributeAssignments1(child,result,e);
	     }
	   } else if (child.isFalse(e)) {
	     List grandChildren = child.childVarAttributeAssignments(e);
	     if (containsAttribute(child.getName(),grandChildren)) {
	       for (Iterator i1=grandChildren.iterator();i1.hasNext();) {
		 result.add(i1.next());
	       }
	     } else {
	       result.add(child);
	     }
	   } else {
	     result.add(child);
	   }
	 }
	 return result;
  }

  /* Second helper function for childVarAttributeAssignments() */
  public boolean containsAttribute(String name, List assignments) {
    for (Iterator i=assignments.iterator();i.hasNext();) {
      AttributeAssignment a = (AttributeAssignment)i.next();
      if (name.equals(a.getName())) return true;
    }
    return false;
  }

  /* Generate a vector of of the assumptions supporting this
     assignment. */
  public List childLeafAttributeAssignments(ScenarioInterface e) {
    // System.out.println("in childLeafAttributeAssignments");
    List result = new ArrayList();
    for (Iterator i=childPropAttributeAssignments(e).iterator();i.hasNext();) {
      AttributeAssignment c = (AttributeAssignment)i.next();
      childLeafAttributeAssignments1(c,result,e);
    }
    return result;
  }
  public List childLeafAttributeAssignments1(AttributeAssignment assignment,List result,ScenarioInterface e) {
    List children = assignment.childPropAttributeAssignments(e);
    if (children.size()==0) {
      result.add(assignment);
    } else {
      for (Iterator i=children.iterator();i.hasNext();)
	childLeafAttributeAssignments1((AttributeAssignment)(i.next()),result,e);
    }
    return result;
  }

}                     
