$Id: DEVELOPERS,v 1.6 2001/11/17 00:05:12 lbrown Exp $

See the file "mba/disclaimers-and-notices-L2.txt" for
information on usage and redistribution of this file,
and for a DISCLAIMER OF ALL WARRANTIES.

This file includes instructions for developers.

Checking changes in:
====================

Always write a ChangeLog entry.  It documents the changes you made, which
is important for other developers whose code this might affect.

The format of a ChangeLog entry is the following:

date  name   email
        General description.
        * file1 (func1) : description
                (func2) : description
        * file2 (func1, func2) : description
        * file3, file4 (func1, func2): description

The date format is yyyy-mm-dd
The filenames are relative to mba/cpp.

Each entry should document a single change.  Try to make that change
minimal (no unreleated fixes; checkin the one change, then checkin another
change for the unrelated fix).

For self-explanatory changes, don't bother with the general description.

In a makefile, the function might be a make rule; in documentation, the
chapter name.

The description needn't be very long.  The description for a new function
need only be 'added' ; similarly, for a removed one, 'removed' (and if
you've added/removed an entire file, don't enumerate all the functions in
it).  The goal of the description is to point out exactly where things
changed, and perhaps some idea of how it changed.




Naming conventions
==================

The de-facto naming convention, which is sometimes violated, is:
    filenames: all lower-case, matches the name of the class it
            describes
            Source files are in a subdirectory of src/
            Header files are in a subdirectory of include/

    classes:
            Upper-case initial letter (letters, for acronyms),
            otherwise lower-case;
            underscores between words

    functions, variables:
            all lower-case
            underscores between words




Using the configure scripts:
============================

L2 uses GNU autoconf configure scripts.  This means two things:
        firstly, Makefiles will be generated from Makefile.in ; so if you
        change Makefile, as soon as you configure, the changes will go
        away; you need to change Makefile.in instead.  See below.

        in general, if you need to write code that works one way on one
        platform, and another way on another, write a piece of autoconf
        code to do the check rather than trying to find some set of
        #defines that happens to also occur on those platforms.  So, for
        instance, instead of writing in your code:
                #ifndef VXWORKS
                #define EOS 0
                #endif
        make a test in configure.in:
            case $host in
                    *vxworks*)  ;;
                    *) AC_DEFINE(EOS,0) ;;
            esac
        or even better:
            AC_EGREP_CPP(yes,
                [#ifdef EOS
                  yes
                #endif
                ], , AC_DEFINE(EOS,0))
        or (probably best in this case) write your code such that it
        doesn't use platform-dependent stuff: just don't use EOS and use
        '\0' instead.

        See the documentation for autoconf.

To add an optional package (like the JNI or RTI), put the code into its own
directory.  Use the LIV_ARG_ENABLE macro to check whether it's enabled; the
default should be the minimum that works with stanley (hence JNI is on by
default, RTI is off).

If the feature is enabled, add the directory (or directories) to
FEATURE_DIRS if it includes code to add to liblivdll.so ; or to
NOLIB_FEATURE_DIRS if it's for instance another executable.

If you AC_DEFINE something, you must add an entry in acconfig.h and run
autoheader to regenerate gnu_conf.h.in




How to write a Makefile.in:
===========================

Makefile is generated by concatenating top.mk, your Makefile.in, and
bot.mk.  top and bot.mk are files in the root directory of the l2
distribution are inavariable from directory to directory; Makefile.in is in
the current directory and varies as needed.

Simplest case
-------------
If the directory implements a feature to add to the liblivdll.so library,
likely all you have to do is:
        OBJECTS = file1.o file2.o file3.o
And you're done.  If the directory is included as a feature, the object
files thus named will be included in the library; the corresponding .cpp or
.c files will be compiled to generate the .o files.


If the directory is for an executable, it's a bit more complicated:
        MY_OBJECTS = file1.o file2.o file3.o
        TARGET    = my_executable
        BINTARGET = my_executable

        my_executable : $(MY_OBJECTS)
                $(LINKEXEC) -o $@ $(MY_OBJECTS)

The names 'MY_OBJECTS' and 'my_executable' aren't special; you can change
them to fit your needs (but don't use one of the variables listed below).

The variable 'TARGET' is what is built when you do a make all ; the
variable 'BINTARGET' specifies that it's a binary and should be installed
in $(bindir).  LIBTARGET would be similar, but install in $(libdir).


More details
------------
top.mk defines a bunch of variables you may need to use.  Chief among those:
        $(CXX)          -- the C++ compiler
        $(loc_libdir)   -- the directory into which you should compile you
                           libraries
        $(libdir)       -- the directory into which libraries will be
                           installed
        $(LINKLIB)      -- a program to create a shared object
        $(LINKEXEC)     -- a program to create an executable

bot.mk defines a bunch of rules to build your program.  It relies on some
variables you define in your Makefile.in :
        $(TARGET)       -- `make' (or `make all') will compile this single
                           file.  `make clean' will remove it.  If you
                           don't want `make clean' to remove it, just
                           add an all target instead of using $(TARGET)
        $(LIBTARGET)    -- a library target; you won't even need to write
                           a rule to link it if you specify this.  This
                           must be a file that is matched by
                           ${loc_libdir}/lib%.la
        $(BINTARGET)    -- a binary target; you will need to write a rule
                           to link it (use LINKEXEC to do that), but you
                           won't need a rule to install this.
        $(DEPS)         -- other L2 libraries that $(TARGET) depends on;
                           they will be compiled first, and linked with
                           $(TARGET)
        $(OBJECTS)      -- the names of the files that will be linked
                           together into the liblivdll library.  Each
                           name must end in .o

In addition, you may want to append to these (write as `VAR += value')
        $(LIBS)         -- libraries the target needs to be linked with
        $(LDFLAGS)      -- -L flags passed to the linker
        $(DEFS)         -- -D flags passed to the compiler
        $(CPPFLAGS)     -- -I flags passed to the compiler

        $(BININSTALL)   -- targets in $(bindir) and $(libdir) which will
        $(LIBINSTALL)      be installed on `make install'.  $(BINTARGET)
                           and $(LIBTARGET) are automatically installed,
                           so you likely won't need to change these.

        $(CLEANFILES)   -- additional files to remove on make clean,
        $(DCLEANFILES)     distclean, or maintainer-clean, respectively.
        $(MCLEANFILES)     The default gets rid of most things, including
                           TARGET (but not BINTARGET or LIBTARGET)


bhudson@arc.nasa.gov set up the configure scripts and Makefile.in ; mail
questions to him.
